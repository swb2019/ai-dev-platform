name: Deploy Production

author: ai-dev-platform

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: read
  id-token: write
  packages: write

concurrency:
  group: deploy-production
  cancel-in-progress: true

jobs:
  context:
    name: Context
    runs-on: ubuntu-latest
    steps:
      - run: echo "::notice::Deploy production workflow triggered on $GITHUB_REF via $GITHUB_EVENT_NAME"

  skip:
    if: github.event_name == 'push' && github.ref != 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - run: echo "Production deploy runs only on main; current ref ${{ github.ref }}."

  deploy-gate:
    name: Deploy to Production - Gate
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.evaluate.outputs.should_run }}
      reason: ${{ steps.evaluate.outputs.reason }}
    steps:
      - id: evaluate
        env:
          PRODUCTION_ENABLED: ${{ vars.PRODUCTION_DEPLOY_ENABLED }}
          SECRET_IMAGE_REPO: ${{ secrets.PRODUCTION_IMAGE_REPO }}
          SECRET_REGISTRY_HOST: ${{ secrets.PRODUCTION_ARTIFACT_REGISTRY_HOST }}
          SECRET_GCP_PROJECT_ID: ${{ secrets.PRODUCTION_GCP_PROJECT_ID }}
          SECRET_GKE_LOCATION: ${{ secrets.PRODUCTION_GKE_LOCATION }}
          SECRET_GKE_CLUSTER: ${{ secrets.PRODUCTION_GKE_CLUSTER }}
          SECRET_WIP: ${{ secrets.PRODUCTION_WORKLOAD_IDENTITY_PROVIDER }}
          SECRET_WISA: ${{ secrets.PRODUCTION_WORKLOAD_IDENTITY_SERVICE_ACCOUNT }}
          SECRET_RUNTIME_GSA: ${{ secrets.PRODUCTION_RUNTIME_GSA_EMAIL }}
        run: |
          set -euo pipefail
          should_run=false
          reason=""

          if ! { [ "$PRODUCTION_ENABLED" = "true" ] || [ -z "$PRODUCTION_ENABLED" ]; }; then
            reason="enable vars.PRODUCTION_DEPLOY_ENABLED"
          fi

          check_secret() {
            local value="$1"
            local name="$2"
            if [ -z "$value" ]; then
              if [ -n "$reason" ]; then
                reason+=" "
              fi
              reason+="missing_secret:${name}"
            fi
          }

          if [ -z "$reason" ]; then
            check_secret "$SECRET_IMAGE_REPO" "PRODUCTION_IMAGE_REPO"
            check_secret "$SECRET_REGISTRY_HOST" "PRODUCTION_ARTIFACT_REGISTRY_HOST"
            check_secret "$SECRET_GCP_PROJECT_ID" "PRODUCTION_GCP_PROJECT_ID"
            check_secret "$SECRET_GKE_LOCATION" "PRODUCTION_GKE_LOCATION"
            check_secret "$SECRET_GKE_CLUSTER" "PRODUCTION_GKE_CLUSTER"
            check_secret "$SECRET_WIP" "PRODUCTION_WORKLOAD_IDENTITY_PROVIDER"
            check_secret "$SECRET_WISA" "PRODUCTION_WORKLOAD_IDENTITY_SERVICE_ACCOUNT"
            check_secret "$SECRET_RUNTIME_GSA" "PRODUCTION_RUNTIME_GSA_EMAIL"
          fi

          if [ -z "$reason" ]; then
            should_run=true
            reason="ready"
          fi

          echo "should_run=$should_run" >> "$GITHUB_OUTPUT"
          echo "reason=$reason" >> "$GITHUB_OUTPUT"

  explain-deploy-skip:
    name: Deploy to Production (skipped)
    needs: deploy-gate
    if: ${{ needs.deploy-gate.outputs.should_run != 'true' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo "::notice::Production deploy skipped â€“ ${{ needs.deploy-gate.outputs.reason }}"

  deploy:
    name: Deploy to Production
    needs: deploy-gate
    if: ${{ needs.deploy-gate.outputs.should_run == 'true' }}
    runs-on: ubuntu-latest
    environment: production
    env:
      IMAGE_TAG: ${{ github.ref_name }}
      IMAGE_REPO: ${{ secrets.PRODUCTION_IMAGE_REPO }}
      REGISTRY_HOST: ${{ secrets.PRODUCTION_ARTIFACT_REGISTRY_HOST }}
      GCP_PROJECT_ID: ${{ secrets.PRODUCTION_GCP_PROJECT_ID }}
      GKE_LOCATION: ${{ secrets.PRODUCTION_GKE_LOCATION }}
      GKE_CLUSTER: ${{ secrets.PRODUCTION_GKE_CLUSTER }}
      KUSTOMIZE_OVERLAY: deploy/k8s/overlays/prod
      SBOM_OUTPUT: artifacts/sbom/web-${{ github.sha }}-cyclonedx.json
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud (WIF)
        id: auth
        uses: google-github-actions/auth@v2
        with:
          token_format: access_token
          workload_identity_provider: ${{ secrets.PRODUCTION_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.PRODUCTION_WORKLOAD_IDENTITY_SERVICE_ACCOUNT }}

      - name: Setup gcloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker "${{ secrets.PRODUCTION_ARTIFACT_REGISTRY_HOST }}" --quiet

      - name: Install supply chain tooling
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends curl jq
          TRIVY_VERSION=0.55.2
          GRYPE_VERSION=0.79.3
          SYFT_VERSION=1.33.0
          COSIGN_VERSION=2.3.0
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin v${TRIVY_VERSION}
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sudo sh -s -- -b /usr/local/bin v${GRYPE_VERSION}
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin v${SYFT_VERSION}
          curl -sSL https://github.com/sigstore/cosign/releases/download/v${COSIGN_VERSION}/cosign-linux-amd64 -o cosign
          sudo install -m 0755 cosign /usr/local/bin/cosign
          rm cosign

      - name: Build container image
        run: bash scripts/container/supply-chain.sh build

      - name: Scan container image
        run: bash scripts/container/supply-chain.sh scan

      - name: Generate SBOM
        run: bash scripts/container/supply-chain.sh sbom

      - name: Push image to Artifact Registry
        run: docker push "${IMAGE_REPO}:${IMAGE_TAG}"

      - name: Sign image and SBOM
        env:
          COSIGN_YES: 'true'
        run: bash scripts/container/supply-chain.sh sign

      - name: Resolve image digest
        id: image
        run: |
          set -euo pipefail
          FULL_REF=$(gcloud artifacts docker images describe "${IMAGE_REPO}:${IMAGE_TAG}" --format='value(image_summary.fully_qualified_digest)')
          if [[ -z "$FULL_REF" ]]; then
            echo "Unable to resolve image digest" >&2
            exit 1
          fi
          DIGEST="${FULL_REF#*@}"
          echo "full_ref=$FULL_REF" >> "${GITHUB_OUTPUT}"
          echo "digest=$DIGEST" >> "${GITHUB_OUTPUT}"

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Patch production overlay with runtime metadata
        env:
          IMAGE_DIGEST: ${{ steps.image.outputs.digest }}
          RUNTIME_GSA: ${{ secrets.PRODUCTION_RUNTIME_GSA_EMAIL }}
        run: |
          yq -i '.images = [{"name": "IMAGE_PLACEHOLDER", "newName": env(IMAGE_REPO), "digest": env(IMAGE_DIGEST)}]' deploy/k8s/overlays/prod/kustomization.yaml
          yq -i '.metadata.annotations."iam.gke.io/gcp-service-account" = env(RUNTIME_GSA)' deploy/k8s/overlays/prod/patches/serviceaccount-annotation.yaml

      - name: Verify production overlay immutability
        env:
          EXPECTED_IMAGE_REPO: ${{ env.IMAGE_REPO }}
        run: bash scripts/kustomize/verify-overlay.sh "${{ env.KUSTOMIZE_OVERLAY }}" "${EXPECTED_IMAGE_REPO}"

      - name: Fetch GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          project_id: ${{ secrets.PRODUCTION_GCP_PROJECT_ID }}
          cluster_name: ${{ secrets.PRODUCTION_GKE_CLUSTER }}
          location: ${{ secrets.PRODUCTION_GKE_LOCATION }}

      - name: Apply manifests
        run: kubectl apply -k deploy/k8s/overlays/prod

      - name: Wait for rollout
        run: kubectl rollout status deployment/web --namespace web --timeout=5m
