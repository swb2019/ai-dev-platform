# Hardening Runbook

This runbook lists the operational tasks required to make the AI Dev Platform deployments as tamper-resistant as possible. Execute the steps in order when standing up a new environment or auditing an existing one.

## 1. Cloud Project Baseline

1. **Dedicated projects per environment.** Provision separate GCP projects for development, staging, and production. Restrict IAM so only automation identities have write access outside of emergency break-glass accounts.
2. **Networking boundaries.** Create isolated VPC networks per environment. Disallow VPC peering between production and lower environments unless explicitly required for shared services.
3. **Artifact Registry permissions.** Grant `Artifact Registry Administrator` only to GitHub Actions Workload Identity service accounts. Developers should have `Artifact Registry Reader` at most; deny pushes outside CI.

## 2. Identity and Access Management

1. **Workload Identity Federation (WIF).** Create one provider per GitHub environment. Bind provider audiences to repository workflows and grant `roles/iam.workloadIdentityUser` only to the CI identities.
2. **Service account hygiene.** Disable key creation on CI, runtime, and Terraform service accounts. Rotate any legacy keys and remove unused principals.
3. **Just-In-Time (JIT) access.** Route human administrative access through Access Approval, IAM Conditions, or Privileged Access Manager so elevated roles automatically expire.

## 3. GitHub Organization Controls

1. **Rulesets and branch protections.** Apply org-level rulesets enforcing signed commits, mandatory status checks (`CI / Security Scans`, `CI / Quality Gates`, `CI / Supply Chain`, `Infra Drift Detection`, Terraform plans), and Require Approval for deployments.
2. **SSO enforcement.** Require SAML/SSO and hardware-backed MFA for all organization members. Enable GitHub Advanced Security enterprise-wide where licensing allows.
3. **Secret scanning and push protection.** Confirm GitHub secret scanning (including push protection) is enabled at the org level to catch leaked credentials before they reach `main`.

## 4. Cluster Policy & Runtime Security

1. **Gatekeeper installation.** Deploy Gatekeeper to every GKE cluster and apply the repository policies via `./scripts/policy/apply-gatekeeper.sh`.
2. **Additional constraints.** Layer on Pod Security Standards (restricted), container runtime rules (no hostPath, privilege escalation), and namespace whitelisting as needed for your workloads.
3. **Runtime monitoring.** Deploy Falco or GKE Security Posture dashboards to detect suspicious runtime behaviour. Feed alerts into the central SIEM.

## 5. Supply Chain Assurance

1. **Binary Authorization attestors.** Create separate attestors per environment. Require Cosign signatures and SBOM attestations before allowing admission.
2. **Vulnerability management.** Configure Container Analysis to alert on new CVEs for shipped image digests. Track remediation SLA in ticketing.
3. **SBOM storage.** Store generated SBOMs in an immutable bucket or artifact store with retention policies aligned to compliance requirements.

## 6. Continuous Verification

1. **Terraform drift.** Ensure `.github/workflows/infra-drift.yml` succeeds daily. Triage failures immediately and reconcile drift through reviewed PRs.
2. **Kubernetes reconcilers.** Add scheduled jobs that run `kubectl diff -k deploy/k8s/overlays/<env>` and alert when live manifests diverge from Git.
3. **Backups and restores.** Automate database and state backups. Execute quarterly restore tests and document recovery times.

## 7. Incident Response & Documentation

1. **Runbooks.** Maintain environment-specific runbooks for common incidents (secret rotation, failed deploy, cluster compromise). Store them in `docs/runbooks/`.
2. **Tabletop exercises.** Conduct at least two security incident simulations per year covering supply-chain compromise and credential leakage.
3. **Forensics tooling.** Pre-stage tooling (e.g., snapshots, audit logging exports) required for investigations so it is accessible without elevating privileges mid-incident.
4. **Agent segregation.** Enforce that Codex/Claude agents work only in sandboxes generated by `scripts/agent/create-project-workspace.sh`. The platform repository remains human-only; all promotions back into the platform flow through signed commits and protected branches.
5. **Constrained execution.** Launch agent sessions via `scripts/agent/run-sandbox-container.sh` (preferably with gVisor/Kata runtimes) so each run occurs inside a locked-down container with no direct host or cloud credential access.

Review this checklist quarterly. Add new requirements as regulations, infrastructure topology, or threat models evolve.
